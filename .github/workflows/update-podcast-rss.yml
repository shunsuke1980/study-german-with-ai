name: Update Podcast RSS Feed

on:
  push:
    paths:
      - 'assets/audio/*.mp3'
    branches:
      - main
  workflow_dispatch: # Allow manual triggering

jobs:
  update-podcast-rss:
    runs-on: ubuntu-latest
    permissions:
      contents: write

    steps:
    - name: Checkout repository
      uses: actions/checkout@v4

    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.11'

    - name: Generate Podcast RSS Feed
      run: |
        python << 'EOF'
        import os
        import re
        import xml.etree.ElementTree as ET
        from datetime import datetime, timezone
        from pathlib import Path
        import email.utils

        def get_file_size(file_path):
            """Get file size in bytes"""
            try:
                return os.path.getsize(file_path)
            except OSError:
                return 0

        def estimate_duration(file_size_bytes):
            """Estimate MP3 duration from file size (assuming 128kbps)"""
            # 128 kbps = 16 KB/s
            # Duration in seconds = file_size_bytes / 16000
            duration_seconds = max(1, file_size_bytes // 16000)

            hours = duration_seconds // 3600
            minutes = (duration_seconds % 3600) // 60
            seconds = duration_seconds % 60

            if hours > 0:
                return f"{hours:02d}:{minutes:02d}:{seconds:02d}"
            else:
                return f"{minutes:02d}:{seconds:02d}"

        def parse_blog_frontmatter(blog_file):
            """Extract title and topic from blog post YAML frontmatter"""
            title = None
            topic = None

            try:
                with open(blog_file, 'r', encoding='utf-8') as f:
                    content = f.read()

                if content.startswith('---'):
                    # Find the end of frontmatter
                    end_marker = content.find('---', 3)
                    if end_marker != -1:
                        frontmatter = content[3:end_marker]

                        for line in frontmatter.split('\n'):
                            line = line.strip()
                            if line.startswith('title:'):
                                title = line.split('title:', 1)[1].strip().strip('"\'')
                            elif line.startswith('topic:'):
                                topic = line.split('topic:', 1)[1].strip().strip('"\'')

            except Exception as e:
                print(f"Error parsing blog file {blog_file}: {e}")

            return title, topic

        def find_blog_file(date_str):
            """Find corresponding blog file for a given date"""
            # Check both _posts and blog directories
            possible_dirs = ['_posts', 'blog']
            possible_patterns = [
                f"{date_str}.md",  # Old format
                f"{date_str}-*.md"  # Jekyll format
            ]

            for dir_name in possible_dirs:
                dir_path = Path(dir_name)
                if dir_path.exists():
                    for pattern in possible_patterns:
                        matches = list(dir_path.glob(pattern))
                        if matches:
                            # Return the first match that's not a -jp.md or -en.md file
                            for match in matches:
                                if not (match.name.endswith('-jp.md') or
                                       match.name.endswith('-en.md') or
                                       'weekly' in match.name.lower()):
                                    return match
            return None

        def create_podcast_rss():
            """Generate podcast RSS feed"""
            print("üéôÔ∏è Generating podcast RSS feed...")

            # Use custom domain
            base_url = "https://www.study-german.info"
            email_address = "24.madding_cuts@icloud.com"

            print(f"Base URL: {base_url}")

            # Create RSS root element
            rss = ET.Element('rss')
            rss.set('version', '2.0')
            rss.set('xmlns:itunes', 'http://www.itunes.com/dtds/podcast-1.0.dtd')
            rss.set('xmlns:content', 'http://purl.org/rss/1.0/modules/content/')

            channel = ET.SubElement(rss, 'channel')

            # Podcast metadata
            ET.SubElement(channel, 'title').text = "Study German with AI (A2)"
            ET.SubElement(channel, 'description').text = "Daily A2-level German learning content with AI-optimized materials"
            ET.SubElement(channel, 'link').text = base_url
            ET.SubElement(channel, 'language').text = "de-DE"
            ET.SubElement(channel, 'copyright').text = f"¬© {datetime.now().year} AI German Learning System"
            ET.SubElement(channel, 'managingEditor').text = f"{email_address} (AI German Learning System)"
            ET.SubElement(channel, 'webMaster').text = f"{email_address} (AI German Learning System)"
            ET.SubElement(channel, 'pubDate').text = email.utils.formatdate(datetime.now().timestamp())
            ET.SubElement(channel, 'lastBuildDate').text = email.utils.formatdate(datetime.now().timestamp())
            ET.SubElement(channel, 'generator').text = "AI German Learning System"

            # iTunes-specific tags
            ET.SubElement(channel, 'itunes:author').text = "AI German Learning System"
            ET.SubElement(channel, 'itunes:summary').text = "Daily A2-level German learning content with AI-optimized materials for language learners"

            # iTunes owner (no duplicate empty tag)
            owner = ET.SubElement(channel, 'itunes:owner')
            ET.SubElement(owner, 'itunes:name').text = "AI German Learning System"
            ET.SubElement(owner, 'itunes:email').text = email_address

            ET.SubElement(channel, 'itunes:explicit').text = "false"
            ET.SubElement(channel, 'itunes:type').text = "episodic"

            # Category
            category = ET.SubElement(channel, 'itunes:category')
            category.set('text', 'Education')
            subcategory = ET.SubElement(category, 'itunes:category')
            subcategory.set('text', 'Language Learning')

            # Image/artwork (REQUIRED for Apple Podcasts)
            itunes_image = ET.SubElement(channel, 'itunes:image')
            itunes_image.set('href', f"{base_url}/assets/images/podcast.jpg")

            # Find all MP3 files
            audio_dir = Path('assets/audio')
            if not audio_dir.exists():
                print("‚ùå No assets/audio directory found")
                return

            mp3_files = list(audio_dir.glob('*.mp3'))
            if not mp3_files:
                print("‚ùå No MP3 files found")
                return

            print(f"üìÅ Found {len(mp3_files)} MP3 files")

            # Sort files by date (newest first for podcast feed)
            episodes = []

            for mp3_file in mp3_files:
                # Extract date from filename (YYYY-MM-DD format)
                date_match = re.match(r'^(\d{4}-\d{2}-\d{2})', mp3_file.stem)
                if not date_match:
                    print(f"‚ö†Ô∏è Skipping {mp3_file.name} - invalid date format")
                    continue

                date_str = date_match.group(1)
                print(f"üìÖ Processing {mp3_file.name} for date {date_str}")

                try:
                    episode_date = datetime.strptime(date_str, '%Y-%m-%d')
                except ValueError:
                    print(f"‚ö†Ô∏è Skipping {mp3_file.name} - invalid date")
                    continue

                # Find corresponding blog file
                blog_file = find_blog_file(date_str)
                title = None
                topic = None

                if blog_file:
                    print(f"üìñ Found blog file: {blog_file}")
                    title, topic = parse_blog_frontmatter(blog_file)

                # Generate episode metadata
                if not title:
                    title = f"[A2] Deutsch des Tages - {date_str}"

                if not topic:
                    topic = "A2-level German learning content"

                file_size = get_file_size(mp3_file)
                duration = estimate_duration(file_size)

                episode_data = {
                    'date': episode_date,
                    'date_str': date_str,
                    'title': title,
                    'topic': topic,
                    'file_path': mp3_file,
                    'file_size': file_size,
                    'duration': duration,
                    'audio_url': f"{base_url}/assets/audio/{mp3_file.name}"
                }

                episodes.append(episode_data)
                print(f"‚úÖ Episode: {title} ({duration})")

            # Sort episodes by date (newest first)
            episodes.sort(key=lambda x: x['date'], reverse=True)

            # Generate episode items
            for i, episode in enumerate(episodes):
                item = ET.SubElement(channel, 'item')

                # Basic episode info
                ET.SubElement(item, 'title').text = episode['title']
                ET.SubElement(item, 'description').text = f"A2 German learning episode about: {episode['topic']}"
                ET.SubElement(item, 'link').text = f"{base_url}/"
                ET.SubElement(item, 'guid').text = f"{base_url}/episodes/{episode['date_str']}"

                # Publication date
                pub_date = episode['date'].replace(hour=9, minute=0, second=0, tzinfo=timezone.utc)
                ET.SubElement(item, 'pubDate').text = email.utils.formatdate(pub_date.timestamp())

                # Audio enclosure
                enclosure = ET.SubElement(item, 'enclosure')
                enclosure.set('url', episode['audio_url'])
                enclosure.set('length', str(episode['file_size']))
                enclosure.set('type', 'audio/mpeg')

                # iTunes-specific episode tags
                ET.SubElement(item, 'itunes:title').text = episode['title']
                ET.SubElement(item, 'itunes:summary').text = f"Daily German A2 learning content covering: {episode['topic']}"
                ET.SubElement(item, 'itunes:duration').text = episode['duration']
                ET.SubElement(item, 'itunes:episode').text = str(len(episodes) - i)  # Episode number
                ET.SubElement(item, 'itunes:episodeType').text = "full"
                ET.SubElement(item, 'itunes:explicit').text = "false"

            # Write RSS file
            # Format the XML for better readability
            def indent(elem, level=0):
                i = "\n" + level * "  "
                if len(elem):
                    if not elem.text or not elem.text.strip():
                        elem.text = i + "  "
                    if not elem.tail or not elem.tail.strip():
                        elem.tail = i
                    for child in elem:
                        indent(child, level + 1)
                    if not child.tail or not child.tail.strip():
                        child.tail = i
                else:
                    if level and (not elem.tail or not elem.tail.strip()):
                        elem.tail = i

            indent(rss)

            # Create XML tree and write to file
            tree = ET.ElementTree(rss)

            # Write with XML declaration
            with open('podcast.rss', 'wb') as f:
                f.write(b'<?xml version="1.0" encoding="UTF-8"?>\n')
                tree.write(f, encoding='utf-8', xml_declaration=False)

            print(f"‚úÖ Generated podcast.rss with {len(episodes)} episodes")

            # Verify the file was created
            if Path('podcast.rss').exists():
                file_size = Path('podcast.rss').stat().st_size
                print(f"üìÑ RSS file size: {file_size} bytes")
            else:
                print("‚ùå Failed to create podcast.rss file")

        # Run the RSS generation
        create_podcast_rss()
        EOF

    - name: Commit and push RSS feed
      run: |
        git config --local user.email "action@github.com"
        git config --local user.name "Podcast RSS Generator"

        # Pull latest changes first
        git pull --rebase origin main || true

        git add podcast.rss
        if git diff --staged --quiet; then
          echo "No changes to RSS feed"
        else
          git commit -m "Update podcast RSS feed with latest episodes"

          # Try to push with retry logic
          for i in {1..3}; do
            if git push; then
              echo "RSS push successful on attempt $i"
              break
            else
              echo "RSS push failed on attempt $i, pulling and retrying..."
              git pull --rebase origin main || true
              sleep 2
            fi
          done
        fi

    - name: Display RSS feed info
      run: |
        if [ -f "podcast.rss" ]; then
          echo "‚úÖ Podcast RSS feed generated successfully"
          echo "üìä RSS file size: $(stat -c%s podcast.rss 2>/dev/null || wc -c < podcast.rss) bytes"
          echo "üîó RSS feed will be available at: https://www.study-german.info/podcast.rss"
          echo "üì± Add this URL to your podcast app!"
          echo ""
          echo "‚úÖ Apple Podcasts Compliance:"
          echo "  ‚Ä¢ iTunes image tag: Added"
          echo "  ‚Ä¢ iTunes owner tag: Fixed (no duplicates)"
          echo "  ‚Ä¢ Email address: study.german.ai@gmail.com"
          echo "  ‚Ä¢ Custom domain: https://www.study-german.info"
          echo "  ‚Ä¢ XML formatting: Proper line breaks"
        else
          echo "‚ùå Failed to generate RSS feed"
        fi